<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Case Study</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="spotify_case_study.css">
</head>

<body>
    <section id="introduction">
        <div class="container">
            <h2>üéµ Smart Playlist Generation: Graph Algorithms for Seamless Music Flow</h2>
            <h3>üìò Section 1: Introduction & Problem Definition</h3>
            <p>
                Modern music services like Spotify and Pandora generate playlists using a single seed song and audio
                fingerprinting (based on timbre, tempo, etc.). While this ensures genre consistency, it often fails to
                guarantee smooth transitions between consecutive tracks.
            </p>
            <p>
                To solve this, Flexer et al. (2008) proposed the Start-End Algorithm, which constructs playlists between a
                chosen start song (Ss) and end song (Se). It ranks candidates by a similarity ratio and selects songs spaced
                evenly across this range.
            </p>
            <p>
                However, the algorithm has a critical flaw: it does not ensure adjacent song similarity. Songs may fit the
                global ratio pattern but still transition abruptly. This can break flow and degrade listening experience.
            </p>
            <div class="image-container">
                <img src="./assets/figure16_similarity_jump.png" alt="Start-End Algorithm Similarity Jumps">
                <div class="caption">
                    <strong>Figure:</strong> Start-End algorithm permits similarity jumps 
                </div>
            </div>
            <p>
                The image illustrates how the Start-End algorithm attempts to create smooth playlists by evenly spacing songs based on a similarity ratio from a start to an end track. Ideally, this approach assumes that the perceived similarity between consecutive songs will also be smooth and consistent throughout the playlist.
            </p>
            <p>
                However, the figure reveals the core problem: despite the even spacing in similarity ratios, the actual similarity between adjacent songs can vary greatly. This means that transitions between songs may be sudden or jarring, leading to an inconsistent listening experience that the algorithm fails to fully address.
            </p>
            <h3>üîç Technical Insight</h3>
            <p>
                The algorithm relies on:
                <br> <span class="formula">R(i) = sim(i, Se) / sim(Ss, i)</span>
                <br> But <span class="formula">R(i) ‚âà R(i+1)</span> does not imply <span class="formula">sim(i, i+1)</span> is high. Especially in sparse graphs, adjacent transitions
                can break ‚Äî violating ‚Äúexpertly-determined smoothness‚Äù seen in DJ-curated playlists.
            </p>
            <h3>üß† Takeaway</h3>
            <ul>
                <li>Audio fingerprinting misses subjective, human-level flow.</li>
                <li>Start-End introduces start/end interpolation but fails to ensure local continuity.</li>
                <li>This limitation drives the need for graph-based, adjacency-aware algorithms ‚Äî such as random walks.</li>
            </ul>
        </div>
    </section>
    <!-- Section 2 ¬∑ EAS Algorithm ‚Äì Graph Construction -->
    <section id="eas-algorithm">

        <h2>2. EAS Algorithm ‚Äì Graph Construction</h2>

        <!-- 2.1 Definition and Intuition -------------------------------------------->
        <h3>2.1 What is an Expertly Authored Stream (EAS)?</h3>
        <p>An <strong>Expertly Authored Stream (EAS)</strong> is a curated playlist built by music professionals, such as radio DJs, music supervisors, or editors at streaming platforms. These streams reflect experienced decisions about how songs should flow for mood, theme, and genre cohesion.</p>

        <p>Instead of relying on acoustic similarity alone, EAS-based algorithms extract human-approved song relationships by examining which tracks appear next to each other in these playlists. This results in a high-level, context-aware understanding of song transitions‚Äîsomething traditional audio fingerprinting methods often miss.</p>

        <p>This technique was formalized by <strong>Ragno et al. (2005)</strong> in their ACM paper:
            <a href="https://dl.acm.org/doi/10.1145/1101826.1101842" target="_blank">
                ‚ÄúInferring similarity between music objects‚Äù</a>.
        </p>

        <!-- 2.2 Graph Construction --------------------------------------------------->
        <h3>2.2 Building the Weighted Graph</h3>
        <p>The EAS algorithm turns a playlist into a <strong>weighted directed graph</strong>, where:</p>
        <ul>
            <li><strong>Nodes</strong> represent unique songs.</li>
            <li><strong>Directed edges</strong> represent adjacent transitions (song A ‚Üí song B).</li>
            <li><strong>Edge weights</strong> count how many times the transition occurred across all playlists.</li>
        </ul>

        <h4>Algorithm 1 ‚Äì Converting EAS to Weighted Graph</h4>
        <pre><code class="language-text">
Input : Stream of songs S = [S‚ÇÅ, S‚ÇÇ, ..., S‚Çô]
Output: Weighted directed graph G = (V, w)

1. Initialize vertex set V ‚Üê all unique songs in S
2. For every pair (u, v) ‚àà V √ó V: set w(u, v) ‚Üê 0
3. For i = 1 to n - 1 do:
       w(S[i], S[i+1]) ‚Üê w(S[i], S[i+1]) + 1
4. Return G = (V, w)
  </code></pre>

        <!-- Figure 1 ------------------------------------------------------------------>
        <figure>
            <img src="./assets/figure1_eas_graph.png" alt="Weighted graph from EAS playlists">
            <figcaption>
                <strong>Figure:</strong> Weighted adjacency graph generated from curated playlists using Algorithm 1.
            </figcaption>
        </figure>

        <!-- 2.3 Calculating Song Similarities ---------------------------------------->
        <h3>2.3 Deriving Song Similarities</h3>
        <p>Once the graph is constructed, the next step is to convert edge weights into numerical <strong>similarity scores</strong>. These scores help automatic playlist generators decide which songs are most appropriate to follow a given track.</p>

        <h4>One-Way Similarity</h4>
        <p>One-way similarity treats the edge as a <em>transition probability</em>. For a song <code>u</code>, the probability of jumping to song <code>v</code> is calculated as:</p>
        <pre><code>sim(u, v) = w(u, v) / Œ£<sub>x</sub> w(u, x)</code></pre>
        <p>This is useful for modeling directional user behavior (e.g., ‚Äúwhat‚Äôs most likely to follow song A?‚Äù).</p>

        <!-- Figure 2 ------------------------------------------------------------------>
        <figure>
            <img src="./assets/figure2_oneway_similarity.png" alt="One-way song similarity example">
            <figcaption>
                <strong>Figure:</strong> One-way similarity values derived from edge weights, based on outgoing transitions from song A.
            </figcaption>
        </figure>

        <h4>Two-Way Similarity</h4>
        <p>Two-way similarity is a symmetric metric that considers both directions and gives a balanced view of how tightly two songs are related:</p>
        <pre><code>sim(u, v) = w(u, v) / (Œ£<sub>x</sub> w(u, x) + Œ£<sub>y</sub> w(v, y))</code></pre>
        <p>This method better handles rare songs that always appear next to the same track‚Äîrevealing strong, even if infrequent, associations.</p>

        <!-- Figure 3 ------------------------------------------------------------------>
        <figure>
            <img src="./assets/figure3_twoway_similarity.png" alt="Two-way song similarity example">
            <figcaption>
                <strong>Figure:</strong> Two-way similarity calculation balances popularity of both connected songs, offering more nuanced similarity values.
            </figcaption>
        </figure>


    </section>

    <!-- Section 3 ¬∑ Start-End Algorithm -->
    <section id="start-end-algorithm" class="snap">
        <div class="container">
            <h2>3. Start-End Algorithm</h2>

            <!-- 3.1 Concept ----------------------------------------------------------->
            <h3>3.1 Overview & Intuition</h3>
            <p>
                Flexer et al.‚Äôs <strong>Start-End Algorithm</strong> (ISMIR 2008) tries to build a playlist that
                <em>smoothly interpolates</em> between a chosen start song <code>S<sub>s</sub></code> and an end song
                <code>S<sub>e</sub></code>. It does so by ranking every candidate track according to a
                <em>similarity ratio</em> that compares how close the track is to each anchor:
            </p>

            <pre><code>R(i) = sim(i, S<sub>e</sub>) / sim(S<sub>s</sub>, i)</code></pre>

            <p>
                Songs are sorted by <code>R(i)</code>; then <code>p</code> positions are sampled at equal
                ‚Äúratio intervals‚Äù between <code>R(S<sub>s</sub>)=‚àû</code> and <code>R(S<sub>e</sub>)=0</code>.
                The closest real song to each ideal position is selected, giving a playlist
                <code>[S<sub>s</sub>, ‚Ä¶, S<sub>e</sub>]</code>.
            </p>

            <!-- Figure 5 ‚Äì ideal vs real ratios -------------------------------------->
            <figure>
                <img src="./assets/figure5_ideal_vs_real.png"
                     alt="Ideal vs real similarity ratios along the number line">
                <figcaption>
                    <strong>Figure:</strong> Mapping ideal similarity ratios (evenly spaced ticks) to the nearest real songs in the catalogue.
                </figcaption>
            </figure>

            <!-- 3.2 Key Steps / Pseudocode ------------------------------------------->
            <h3>3.2 Algorithmic Steps</h3>
            <pre><code class="language-text">
Algorithm 2: Start-End Playlist Generation
Input : Song set S, start song S‚Çõ, end song S‚Çë, desired length p
Output: Ordered playlist P

1  Rank every song by similarity to S‚Çõ  ‚Üí list startSimilarities
2  Rank every song by similarity to S‚Çë  ‚Üí list endSimilarities
3  Remove the bottom t% of songs least similar to both anchors
4  Compute step width:          step = (R(S‚Çõ) - R(S‚Çë)) / (p + 1)
5  For j = 1 ‚Ä¶ p do
       ideal = R(S‚Çõ) - j¬∑step
       pick song closest to ideal ratio   ‚Üí append to P
6  Return playlist  [S‚Çõ, P, S‚Çë]
    </code></pre>

            <!-- Figure 6 ‚Äì selection process ----------------------------------------->
            <figure>
                <img src="./assets/figure6_selection_process.png"
                     alt="Selecting songs closest to target ratios">
                <figcaption>
                    <strong>Figure:</strong> Selection of real tracks (A‚Ä¶I) that best match the target similarity ratio positions ‚Üí final ordering ADECFHGIB.
                </figcaption>
            </figure>

            <!-- 3.3 Weaknesses -------------------------------------------------------->
            <h3>3.3 Practical Weaknesses</h3>
            <ul>
                <li><strong>Sparse-graph constraint:</strong> every chosen track must be connected
                    (non-zero similarity) to both <code>S<sub>s</sub></code> and <code>S<sub>e</sub></code>.
                    In real EAS graphs this is rare ‚Üí algorithm often returns no playlist.</li>
                <li><strong>No local guarantee:</strong> Even if ratio spacing is perfect,
                    adjacent similarity <code>sim(i,i+1)</code> can drop sharply (see Figure 16 in
                    Section 1) resulting in audible ‚Äújumps‚Äù.</li>
            </ul>

            <p class="note">
                These limitations motivated replacement strategies such as the
                <em>Unbiased Random Walk</em> (URW) and <em>Biased Random Walk</em> (BRW),
                which use local graph structure instead of a global ratio.
            </p>
        </div>
    </section>

    <!-- Section 4 ¬∑ Unbiased Random Walk (URW) -->
    <section id="urw-algorithm" class="snap">
        <div class="container">
            <h2>4. Unbiased Random Walk (URW)</h2>

            <!-- 4.1 Overview ---------------------------------------------------------->
            <h3>4.1 Why Random Walks?</h3>
            <p>
              The <strong>Unbiased Random Walk (URW)</strong> algorithm addresses the structural limitations
              of the Start-End method. It performs a <em>Monte Carlo‚Äìstyle walk</em> through the similarity
              graph, stepping from one song to another based on local similarity.
            </p>

            <p>
              At each step, the algorithm selects <code>z</code> random neighbors of the current song
              and chooses the one most similar to it. The walk continues until the playlist reaches
              a length <code>p</code> and ends at the target song.
            </p>

            <h4>Core Parameters</h4>
            <ul>
              <li><strong>z (greediness):</strong> how many neighbors to consider per step</li>
              <li><strong>attempts:</strong> how many retries before giving up</li>
              <li><strong>range:</strong> permitted deviation from target length</li>
            </ul>

            <!-- 4.2 Pseudocode -------------------------------------------------------->
            <h3>4.2 Algorithm 3 ‚Äì URW</h3>
            <pre><code class="language-text">
Input : start song Ss, end song Se, playlist length p, range r
        similarity graph G, greediness z, max attempts

Output: playlist of songs from Ss to Se (or empty list)

1. while attempts < maxAttempts:
2.   runner ‚Üê Ss
3.   playlist ‚Üê [Ss]
4.   while len(playlist) < p + r:
5.     sample z random neighbors of runner
6.     pick one with highest sim(runner, neighbor)
7.     append to playlist, set runner ‚Üê next
8.     if runner == Se and length within range:
9.       return playlist
10. return []
    </code></pre>

            <!-- 4.3 Visual: Convergence Graph ------------------------------------------>
            <figure>
              <img src="./assets/figure7_urw_convergence.png" alt="Greedy URW convergence diagram">
              <figcaption>
                <strong>Figure:</strong> As greediness <code>z ‚Üí ‚àû</code>, URW becomes deterministic
                ‚Äî always choosing the most similar neighbor. But this increases the risk of getting stuck.
              </figcaption>
            </figure>

            <!-- 4.4 Notes and Reference ---------------------------------------------
            <h3>4.3 Insights</h3>
            <ul>
              <li>
                At low <code>z</code>, transitions are more random ‚Üí smoothness drops, but success rate ‚Üë
              </li>
              <li>
                At high <code>z</code>, playlists are smoother, but failure is more likely due to dead ends
              </li>
              <li>
                A ‚Äúsweet spot‚Äù at <code>z = 4</code> was empirically found to balance quality and completion
              </li>
            </ul> -->

            <p class="external-link">
              üìò See also: <a href="https://www.researchgate.net/publication/247330407_Random_Walks_on_Graphs_A_Survey_Combinatorics_Paul_Erdos_is_Eighty" target="_blank">
                ‚ÄúRandom Walks on Graphs‚Äù ‚Äì L√°szl√≥ Lov√°sz (1993)</a>
            </p>
          </div>
    </section>

    <!-- Section 5 ¬∑ Evaluation ‚Äì Matrices and Smoothness -->
    <section id="evaluation-urw" class="snap">
      <div class="container">
        <h2>5. Evaluation ‚Äì Matrices and Smoothness</h2>

        <!-- 5.1 Metrics -->
        <h3>5.1 Evaluation Metrics</h3>
        <p>
          To evaluate the <strong>Unbiased Random Walk (URW)</strong> algorithm, we focus on three criteria:
        </p>
        <ul>
          <li><strong>Adjacent Similarity:</strong> Similarity between each song and its immediate successor.</li>
          <li><strong>Playlist Cohesion:</strong> Overall similarity between non-adjacent songs within the playlist.</li>
          <li><strong>Success Rate:</strong> Percentage of trials where a complete playlist from <code>S<sub>s</sub></code> to <code>S<sub>e</sub></code> is successfully generated.</li>
        </ul>

        <!-- 5.2 Parameters -->
        <h3>5.2 Experimental Parameters</h3>
        <p>The evaluation used the following settings:</p>
        <ul>
          <li>Playlist length: <code>p = 20</code></li>
          <li>Length range: <code>¬±5</code> songs</li>
          <li>Greediness levels: <code>z = 1, 4, 7</code></li>
          <li>Trials: <strong>239 playlists</strong> generated</li>
          <li>Similarity metrics: <em>One-way</em> and <em>Two-way</em></li>
        </ul>

        <!-- 5.3 Visuals -->
        <h3>5.3 Visual Analysis: Similarity Matrices</h3>
        <p>
          Each playlist's transitions are visualized using <strong>grayscale similarity matrices</strong>, where:
        </p>
        <ul>
          <li><strong>Darker cells</strong> indicate higher similarity between two songs.</li>
          <li><strong>Diagonal bands</strong> represent adjacent transitions.</li>
          <li><strong>Off-diagonal darkness</strong> indicates overall playlist cohesion.</li>
        </ul>

        <!-- Image: Example Matrix -->
        <figure>
          <img src="./assets/similarity_matrix_example.png" alt="Similarity Matrix Example" style="max-width: 100%;" />
          <figcaption>
            <strong>Figure:</strong> Example similarity matrix (one-way, greediness = 4).
          </figcaption>
        </figure>

        <!-- 5.4 Insights -->
        <h3>5.4 Insights & Interpretation</h3>
        <ul>
          <li><strong>Greediness = 4</strong> yields the best adjacent similarity while maintaining a high success rate.</li>
          <li>Higher greediness (<code>z = 7</code>) creates smoother transitions but increases the risk of <em>dead ends</em> (playlist generation failure).</li>
          <li><strong>One-way similarity</strong> leads to slightly better local transitions, while <strong>two-way similarity</strong> improves playlist cohesion.</li>
        </ul>

        <!-- Image: Greediness Comparison -->
        <figure>
          <img src="./assets/greediness_comparison_chart.png" alt="Greediness vs Smoothness Chart" style="max-width: 100%;" />
          <figcaption>
            <strong>Figure:</strong> Adjacent similarity improves with greediness, but too high may reduce success rate.
          </figcaption>
        </figure>

        <!-- External Sources -->
        <h3>5.5 References</h3>
        <ul>
          <li>
            Ragno et al. (2005). <em>Inferring similarity between music objects with application to playlist generation</em>.
          </li>
          <li>
            Curbow, J. E. (2016). <em>Blending Two Automatic Playlist Generation Algorithms</em>. Union College.
          </li>
          <li>
            Lov√°sz, L. (1993). <a href="https://cs.yale.edu/homes/spielman/561/2004/readings/lovasz.pdf" target="_blank">Random Walks on Graphs</a>.
          </li>
        </ul>
      </div>
    </section>

    <!-- Section 6 ¬∑ Results ‚Äì Unbiased Random Walk Trials -->
    <section id="urw-results" class="snap">
      <div class="container">
        <h2>6. Results ‚Äì Unbiased Random Walk Trials</h2>

        <!-- 6.1 Setup Summary -->
        <h3>6.1 Experimental Setup</h3>
        <p>
          We ran the URW algorithm to generate <strong>239 playlists</strong> under different parameter settings:
        </p>
        <ul>
          <li><strong>Playlist Length:</strong> 20 songs (with ¬±5 range)</li>
          <li><strong>Similarity Types:</strong> One-way and Two-way</li>
          <li><strong>Greediness (z):</strong> 1 (low), 4 (medium), 7 (high)</li>
        </ul>

        <p>
          Each playlist was evaluated for <em>adjacent similarity</em> and <em>playlist cohesion</em>. Heatmaps and line graphs were created for comparison.
        </p>

        <!-- 6.2 Adjacent Similarity Line Graphs -->
        <h3>6.2 Adjacent Similarity Trends</h3>
        <p>
          The following charts show the average similarity between each song and the next in the playlist, across different values of <code>z</code>:
        </p>

        <figure>
          <img src="./assets/adjacent_similarity_oneway.png" alt="One-way Similarity Line Graph" style="max-width: 100%;" />
          <figcaption><strong>Figure:</strong> One-way similarity (adjacent similarity across 20 songs).</figcaption>
        </figure>

        <figure>
          <img src="./assets/adjacent_similarity_twoway.png" alt="Two-way Similarity Line Graph" style="max-width: 100%;" />
          <figcaption><strong>Figure:</strong> Two-way similarity (adjacent similarity across 20 songs).</figcaption>
        </figure>

        <!-- 6.3 Heatmaps -->
        <h3>6.3 Similarity Matrices (Heatmaps)</h3>
        <p>
          The following heatmaps show overall pairwise similarity between all songs in a playlist, averaged across all runs. A darker diagonal band indicates smoother transitions between adjacent songs.
        </p>

        <!-- Example 1-Way Matrices -->
        <h4>One-Way Similarity</h4>
        <div class="matrix-grid">
          <figure>
            <img src="./assets/urw_1way_z1.png" alt="One-way Matrix z=1" />
            <figcaption>z = 1 (Low Greediness)</figcaption>
          </figure>
          <figure>
            <img src="./assets/urw_1way_z4.png" alt="One-way Matrix z=4" />
            <figcaption>z = 4 (Medium Greediness)</figcaption>
          </figure>
          <figure>
            <img src="./assets/urw_1way_z7.png" alt="One-way Matrix z=7" />
            <figcaption>z = 7 (High Greediness)</figcaption>
          </figure>
        </div>

        <!-- Example 2-Way Matrices -->
        <h4>Two-Way Similarity</h4>
        <div class="matrix-grid">
          <figure>
            <img src="./assets/urw_2way_z1.png" alt="Two-way Matrix z=1" />
            <figcaption>z = 1 (Low Greediness)</figcaption>
          </figure>
          <figure>
            <img src="./assets/urw_2way_z4.png" alt="Two-way Matrix z=4" />
            <figcaption>z = 4 (Medium Greediness)</figcaption>
          </figure>
          <figure>
            <img src="./assets/urw_2way_z7.png" alt="Two-way Matrix z=7" />
            <figcaption>z = 7 (High Greediness)</figcaption>
          </figure>
        </div>

        <!-- 6.4 Interpretation -->
        <h3>6.4 Interpretation</h3>
        <ul>
          <li>Greediness <code>z = 4</code> consistently produced the smoothest transitions (highest adjacent similarity).</li>
          <li>At <code>z = 7</code>, playlists often fail to complete due to reaching dead ends‚Äîdespite better local transitions.</li>
          <li><strong>Two-way similarity</strong> matrices show better global cohesion, while <strong>one-way similarity</strong> produces stronger adjacent links.</li>
        </ul>

        <p>
          Overall, the URW algorithm proved capable of generating smooth, valid playlists across a range of parameters, with a notable sweet spot at <code>z = 4</code>.
        </p>
      </div>
    </section>

    <!-- Section 7 ¬∑ Analysis ‚Äì Comparing URW and Start-End -->
    <section id="analysis-urw-startend" class="snap">
      <div class="container">
        <h2>7. Analysis ‚Äì Comparing URW and Start-End</h2>

        <!-- 7.1 Start-End Algorithm Limitations -->
        <h3>7.1 Limitations of the Start-End Algorithm</h3>
        <ul>
          <li>
            Requires that <strong>every song</strong> in the playlist has non-zero similarity to <code>S<sub>s</sub></code> and <code>S<sub>e</sub></code>.
          </li>
          <li>
            This creates a <strong>rigid requirement</strong> that excludes most songs from consideration, especially in sparse graphs.
          </li>
          <li>
            Relies on a <code>similarity ratio</code> that doesn‚Äôt guarantee <em>adjacent smoothness</em> between neighboring songs.
          </li>
        </ul>

        <figure>
          <img src="./assets/startend_weakness.png" alt="Start-End Algorithm Flaw Illustration" style="max-width: 100%;" />
          <figcaption>
            <strong>Figure:</strong> Start-End's use of similarity ratios may result in uneven transitions.
          </figcaption>
        </figure>

        <!-- 7.2 Strengths of URW -->
        <h3>7.2 Strengths of the URW Algorithm</h3>
        <ul>
          <li>
            Does not require global similarity between all songs and both anchors ‚Äì <strong>flexible and scalable</strong>.
          </li>
          <li>
            Guarantees <strong>non-zero local similarity</strong> between each song and its immediate successor.
          </li>
          <li>
            Demonstrates a tunable balance between <strong>smoothness</strong> and <strong>success rate</strong> via the <code>z</code> parameter.
          </li>
        </ul>

        <!-- 7.3 Weaknesses and Challenges -->
        <h3>7.3 Weaknesses and Open Problems</h3>
        <ul>
          <li>
            <strong>Too greedy (high z)</strong> leads to <em>dead ends</em> ‚Äî the playlist cannot complete.
          </li>
          <li>
            URW requires multiple attempts due to its <strong>non-deterministic, trial-and-error nature</strong>.
          </li>
          <li>
            Some playlists still lack <strong>global cohesion</strong> ‚Äì high similarity between distant songs is not guaranteed.
          </li>
        </ul>

        <!-- 7.4 Design Insights -->
        <h3>7.4 Design Insights and Observations</h3>
        <ul>
          <li>
            A <strong>greediness ‚Äúsweet spot‚Äù</strong> was found at <code>z = 4</code>, balancing quality and feasibility.
          </li>
          <li>
            Two-way similarity improves cohesion, but makes the algorithm slightly more prone to failure if normalized improperly.
          </li>
          <li>
            Smooth transitions do not always imply better <em>overall experience</em>; playlist diversity and surprise may also matter.
          </li>
        </ul>

        <!-- Optional Visual -->
        <figure>
          <img src="./assets/urw_deadend_example.png" alt="Dead End Example in URW" style="max-width: 100%;" />
          <figcaption>
            <strong>Figure:</strong> Too much greediness may trap the algorithm with no valid next steps.
          </figcaption>
        </figure>

        <p>
          This analysis reinforces the idea that while the Start-End method struggles under real-world data sparsity, the URW algorithm adapts well to graph-based structures and provides a strong foundation for more advanced playlist generation techniques.
        </p>
      </div>
    </section>


     <!-- Section 10 ¬∑ Efficiency Case Study -->
    <section id="efficiency-summary-playlist-generation" class="snap">
      <div class="container">
        <h2>‚öôÔ∏è Efficiency Summary ‚Äì Playlist Generation Algorithms</h2>
        <table class="efficiency-table">
          <thead>
            <tr>
              <th>Component</th>
              <th>Data Structure / Concept</th>
              <th>Operation</th>
              <th>Time Complexity</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>EAS Graph</td>
              <td>Directed Weighted Graph</td>
              <td>Graph Construction</td>
              <td>O(n)</td>
              <td>Models expert-curated transitions between songs</td>
            </tr>
            <tr>
              <td>Start-End Algorithm</td>
              <td>Sorted List + Ratio Ranking</td>
              <td>Global Ranking, Interpolation</td>
              <td>O(n log n)</td>
              <td>Selects evenly spaced songs from start to end</td>
            </tr>
            <tr>
              <td>Similarity Lookup</td>
              <td>Adjacency Matrix / Edge List</td>
              <td>sim(u, v) calculation</td>
              <td>O(1) for matrix, O(d) list</td>
              <td>Evaluates similarity between songs for path planning</td>
            </tr>
            <tr>
              <td>URW Algorithm</td>
              <td>Randomized Walk over Graph</td>
              <td>Local Neighbor Sampling & Selection</td>
              <td>O(p √ó z)</td>
              <td>Builds smooth playlists using local similarity</td>
            </tr>
            <tr>
              <td>Greediness Heuristic</td>
              <td>Random Sampling + Max Scoring</td>
              <td>Pick best from z neighbors</td>
              <td>O(z) per step</td>
              <td>Controls trade-off between randomness and smoothness</td>
            </tr>
          </tbody>
        </table>
        <p><strong>Notes:</strong></p>
        <ul>
          <li><code>n</code> = total number of songs</li>
          <li><code>p</code> = desired playlist length</li>
          <li><code>z</code> = greediness level (neighbors checked per step)</li>
          <li><code>d</code> = average degree of a node in the graph</li>
        </ul>
      </div>
    </section>

    
    <!-- Section 9 ¬∑ Conclusion and References -->
    <section id="conclusion-references" class="snap">
      <div class="container">
        <h2>9. Conclusion and References</h2>

        <!-- 9.1 Final Conclusion Recap -->
        <h3>9.1 Final Recap</h3>
        <p>
          We examined two competing approaches to automatic playlist generation: the traditional 
          <strong>Start-End algorithm</strong> based on global similarity constraints, and the 
          <strong>Unbiased Random Walk (URW)</strong> algorithm built on graph traversal using local 
          similarity measures derived from <em>Expertly Authored Streams (EAS)</em>.
        </p>
        <p>
          Our analysis showed that URW outperforms the Start-End method in practical settings, 
          offering better adaptability, smoother transitions, and greater robustness in sparse data 
          environments. A greediness parameter around <code>z = 4</code> provides an effective 
          balance between randomness and playlist cohesion.
        </p>
        <p>
          The URW framework presents strong opportunities for future expansion by incorporating 
          audio features, user preferences, and hybrid recommendation architectures.
        </p>

        <!-- 9.2 References -->
        <h3>9.2 References</h3>
        <ol>
          <li>
            Flexer, A., Schnitzer, D., Gasser, M., & Widmer, G. (2008). 
            <em>Playlist generation using start and end songs</em>. 
            In Proceedings of the 9th International Conference on Music Information Retrieval (ISMIR). 
            <a href="https://ismir2008.ismir.net/papers/ISMIR2008_173.pdf" target="_blank">PDF</a>
          </li>
          <li>
            Ragno, R., Burges, C. J., & Herley, C. (2005). 
            <em>Inferring similarity between music objects with application to playlist generation</em>. 
            In Proceedings of the 7th ACM SIGMM International Workshop on Multimedia Information Retrieval. 
            <a href="https://dl.acm.org/doi/10.1145/1101826.1101844" target="_blank">ACM Digital Library</a>
          </li>
          <li>
            Curbow, J. (2016). 
            <em>Blending Two Automatic Playlist Generation Algorithms</em>. 
            Honors Thesis, Union College. 
            <a href="https://digitalworks.union.edu/theses/145" target="_blank">Union College Repository</a>
          </li>
          <li>
            Lov√°sz, L. (1993). 
            <em>Random Walks on Graphs: A Survey</em>. 
            In Combinatorics, Paul Erd≈ës is Eighty. 
            <a href="https://cs.yale.edu/homes/spielman/561/2004/readings/lovasz.pdf" target="_blank">PDF</a>
          </li>
          <li>
            Spotify Web API. 
            <em>Working with Playlists</em>. 
            <a href="https://developer.spotify.com/documentation/web-api/" target="_blank">developer.spotify.com</a>
          </li>
        </ol>

        <p>
          These references ground the theoretical and algorithmic basis for the work presented, 
          providing a credible foundation for ongoing development in intelligent playlist generation systems.
        </p>
      </div>
    </section>

   

    <style>
      .efficiency-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        font-family: 'Inter', sans-serif;
        background-color: #f8f9fa; /* Light gray background */
      }

      .efficiency-table th, .efficiency-table td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: left;
        color: #333; /* Dark text */
      }

      .efficiency-table th {
        background-color: #6c757d; /* Dark gray header */
        color: #fff; /* White text for header */
        font-weight: 600;
      }

      .efficiency-table tr:nth-child(even) {
        background-color: #e9ecef; /* Slightly darker gray for even rows */
      }

      .efficiency-table tr:hover {
        background-color: #adb5bd; /* Highlight row on hover */
      }
    </style>
</body>

</html>